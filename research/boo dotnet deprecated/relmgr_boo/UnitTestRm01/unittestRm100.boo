namespace UnitTestRm01

import RelationshipManager56
import RelationshipManager.Interfaces

import System
import System.Collections
import NUnit.Framework


[TestFixture]
class TestCaseCount:
"""
	New property allows you to count the number of
	relationships of a certain relId.
	
		Count() 					Number of relationship entries in total
		CountRelationships(relId) 	Number of relationship entries matching relId

"""

	private _rm as RelationshipManagerConstrained

	[SetUp]
	def SetUp():
		self._rm = RelationshipManagerConstrained()
		
	[Test]
	def checkCount_01():

		assert _rm.Count() == 0

		_rm.AddRelationship('a', 'b', 'r1')
		_rm.AddRelationship('a', 'c', 'r1')
		_rm.AddRelationship('a', 'd', 'r1')
		
		assert _rm.Count() == 3

		_rm.AddRelationship('z', 'd', 'r1')
		assert _rm.Count() == 4

		_rm.AddRelationship('q', 'w', 'r222')
		assert _rm.Count() == 5

		assert _rm.CountRelationships('r1xxx') == 0

	[Test]
	def checkCount_02_Bidirectional01():

		assert _rm.Count() == 0

		_rm.EnforceRelationship('r1', Cardinality.OneToMany, Directionality.DoubleDirectional)
		_rm.AddRelationship('a', 'b', 'r1')

		assert _rm.Count() == 2
		
		_rm.AddRelationship('a', 'c', 'r1')
		_rm.AddRelationship('a', 'd', 'r1')
		
		//Assert.Equals(6, _rm.Count())
		assert _rm.Count() == 6, "Expected {0} got {1}" % (6, _rm.Count())

		_rm.RemoveRelationship('a', 'b', 'r1')
		assert _rm.Count() == 4

	[Test]
	def checkCountRelationships_01():

		assert _rm.Count() == 0
		assert _rm.CountRelationships("r1") == 0
		assert _rm.CountRelationships("r1zxcsaddasd") == 0
		

		_rm.AddRelationship('a', 'b', 'r1')
		_rm.AddRelationship('a', 'c', 'r1')
		_rm.AddRelationship('a', 'd', 'r1')
		
		assert _rm.Count() == 3
		assert _rm.CountRelationships("r1") == 3
		
		//print _rm.FindObjectsPointedToByMe('a', 'r1')
		//assert _rm.FindObjectsPointedToByMe('a', 'r1') == ['b', 'c', 'd']

		_rm.AddRelationship('z', 'd', 'r1')
		assert _rm.CountRelationships("r1") == 4
		assert _rm.Count() == 4

		_rm.AddRelationship('q', 'w', 'r222')
		assert _rm.CountRelationships("r222") == 1
		assert _rm.Count() == 5
		

		assert _rm.CountRelationships('r1xxx') == 0
	


[TestFixture]
class TestCaseBidirectionality01:
"""
	Test Cases proving you can use backpointer functionality with both 
	directional and bidirectional relationships.

	The ability to use the backpointer feature of relationship manager
	i.e. calling FindObjectsPointingToMe() is not affected by the directionality
	setting.  You can always get the backpointer, no matter what what the direction
	of the relationship is.  Why bother with Directionality.DoubleDirectional then?  Well you may
	prefer to formalise you relationships and make things explicit, rather than
	relying on the magic powers of the relationship manager engine.  Thus in a 
	bidirectional situation you would not need to call for the backpointer, 
	you would instead ask for the appropriate official forward pointer 
	(two official forward pointers exist, remember).
"""

	private _rm as RelationshipManagerConstrained

	[SetUp]
	def SetUp():
		self._rm = RelationshipManagerConstrained()
		
	[Test]
	def CanGetBackpointerOnDirectional():

		_rm.EnforceRelationship('r1', Cardinality.OneToOne, Directionality.DirectionalWithBackPointer)
		_rm.AddRelationship('a', 'b', 'r1')

		assert _rm.FindObjectPointingToMe('b', 'r1') == 'a'

	[Test]
	def CanGetBackpointerOnBi():

		_rm.EnforceRelationship('r1', Cardinality.OneToOne, Directionality.DoubleDirectional)
		_rm.AddRelationship('a', 'b', 'r1')

		// Use magic backpointer abilities of RM
		assert _rm.FindObjectPointingToMe('b', 'r1') == 'a'

		// Or use the official backward pointer, generated by the Directionality.DoubleDirectional option
		// (since it is a really just a normal forward pointer, we use ...PointedToByMe not
		// the backpointer magic of ...PointingToMe)
		assert _rm.FindObjectPointedToByMe('b', 'r1') == 'a'
		
