<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>relmgr.relationship_manager API documentation</title>
<meta name="description" content="Relationship Manager …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>relmgr.relationship_manager</code></h1>
</header>
<section id="section-intro">
<h1 id="relationship-manager">Relationship Manager</h1>
<p>Lightweight Object Database Class for Python.</p>
<p>(c) Andy Bulka 2003 - 2020.</p>
<ul>
<li>
<p>Full <a href="https://abulka.github.io/relationship-manager/relmgr/index.html">API documentation</a> (this page).</p>
</li>
<li>
<p>Official <a href="https://abulka.github.io/projects/patterns/relationship-manager/">Relationship Manager Pattern</a> page incl. academic paper by Andy Bulka.</p>
</li>
<li>
<p>Python Implementation <a href="https://github.com/abulka/relationship-manager">README</a> and <a href="https://github.com/abulka/relationship-manager">GitHub project</a>.</p>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Relationship Manager

Lightweight Object Database Class for Python.

(c) Andy Bulka 2003 - 2020.

- Full [API documentation](https://abulka.github.io/relationship-manager/relmgr/index.html) (this page).

- Official [Relationship Manager Pattern](https://abulka.github.io/projects/patterns/relationship-manager/) page incl. academic paper by Andy Bulka.

- Python Implementation [README](https://github.com/abulka/relationship-manager) and [GitHub project](https://github.com/abulka/relationship-manager).
&#34;&#34;&#34;
import copy
import pickle
import pprint
from dataclasses import dataclass
from functools import lru_cache
from typing import Dict, List, Optional, Set, Tuple, Union
from relmgr._enforcing import _EnforcingRelationshipManager
from relmgr._caching import _RelationshipManagerCaching
from relmgr._persist_support import _Namespace, _PersistenceWrapper


class RelationshipManager():
    &#34;&#34;&#34;Main Relationship Manager to use in your projects.&#34;&#34;&#34;

    def __init__(self, caching: bool = True) -&gt; None:
        &#34;&#34;&#34;Constructor.  Set the option `caching` if you want
        faster performance using Python `lru_cache` technology 
        - defaults to True.
        &#34;&#34;&#34;
        if caching:
            self.rm = _RelationshipManagerCaching()
        else:
            self.rm = _EnforcingRelationshipManager()

        self.objects = _Namespace()
        &#34;&#34;&#34;Optional place for storing objects involved in relationships, so the objects are saved.
        Assign to this `.objects` namespace directly to record your objects
        for persistence puposes.
        &#34;&#34;&#34;

    def _get_relationships(self) -&gt; List[Tuple[object, object, Union[int, str]]]:
        &#34;&#34;&#34;Getter&#34;&#34;&#34;
        return self.rm._get_relationships()

    def _set_relationships(self, listofrelationshiptuples: List[Tuple[object, object, Union[int, str]]]) -&gt; None:
        self.rm._set_relationships(listofrelationshiptuples)
        &#34;&#34;&#34;Setter&#34;&#34;&#34;

    relationships = property(_get_relationships, _set_relationships)
    &#34;&#34;&#34;Property to get flat list of relationships tuples&#34;&#34;&#34;

    def add_rel(self, source, target, rel_id=1) -&gt; None:
        &#34;&#34;&#34;Add relationships between `source` and `target` under the optional
        relationship id `rel_id`. The `source` and `target` are typically Python
        objects but can be strings. The `rel_id` is a string or integer and
        defaults to 1. Note that `rel_id` need not be specified unless you want
        to model multiple different relationships between the same objects, thus
        keeping relationships in different &#39;namespaces&#39; as it were.
        &#34;&#34;&#34;
        self.rm.add_rel(source, target, rel_id)

    def remove_rel(self, source, target, rel_id=1) -&gt; None:
        &#34;&#34;&#34;Remove all relationships between `source` and `target` of type `rel_id`.
        If you specify `None` for any parameter a wildcard match removal will occur.
        For example:

        Syntax    | Meaning
        --------|------
        `remove_rel(&#39;a&#39;, &#39;b&#39;)`     | remove all relationships between &#39;a&#39; and &#39;b&#39;
        `remove_rel(&#39;a&#39;, &#39;b&#39;, None)`     | remove all relationships between &#39;a&#39; and &#39;b&#39;
        `remove_rel(&#39;a&#39;, &#39;b&#39;, &#39;r1&#39;)`     | remove the &#39;r1&#39; relationship between &#39;a&#39; and &#39;b&#39;
        `remove_rel(&#39;a&#39;, None)`     | remove all pointers (relationships) from &#39;a&#39;
        `remove_rel(None, &#39;b&#39;)`     | remove any pointers (relationships) to &#39;b&#39;
        &#34;&#34;&#34;
        self.rm.remove_rel(source, target, rel_id)

    def find_targets(self, source, rel_id=1) -&gt; List:
        &#34;&#34;&#34;Find all objects pointed to by me - all the things &#39;source&#39; is pointing at.&#34;&#34;&#34;
        return self.rm._find_objects(source, None, rel_id)

    def find_target(self, source, rel_id=1) -&gt; object:
        &#34;&#34;&#34;Find first object pointed to by me - first target&#34;&#34;&#34;
        return self.rm._find_object(source, None, rel_id)

    def find_sources(self, target, rel_id=1) -&gt; List:
        &#34;&#34;&#34;Find all objects pointing to me. A &#39;back pointer&#39; query.&#34;&#34;&#34;
        return self.rm._find_objects(None, target, rel_id)

    def find_source(self, target, rel_id=1) -&gt; object:
        &#34;&#34;&#34;Find first object pointing to me - first source. A &#39;back pointer&#39; query.&#34;&#34;&#34;
        return self.rm._find_object(None, target, rel_id)

    def is_rel(self, source, target, rel_id=1) -&gt; bool:
        &#34;&#34;&#34;Returns T/F if relationship exists.&#34;&#34;&#34;
        return self.rm._find_objects(source, target, rel_id)

    def find_rels(self, source, target) -&gt; List:
        &#34;&#34;&#34;Returns a list of the relationships between source and target.
        Returns a list of relationship ids.
        &#34;&#34;&#34;
        return self.rm._find_objects(source, target, None)

    def enforce(self, relId, cardinality, directionality=&#34;directional&#34;):
        &#34;&#34;&#34;Enforce a relationship by auto creating reciprocal relationships in the case of 
        bidirectional relationships, and by overwriting existing relationships if in the case
        of one-to-one cardinality?
        &#34;&#34;&#34;
        self.rm.enforce(relId, cardinality, directionality)

    def dumps(self) -&gt; bytes:
        &#34;&#34;&#34;Dump relationship tuples and objects to pickled bytes.
        The `objects` attribute and all objects stored therein
        (within the instance of `RelationshipManager.objects`) also get persisted.
        &#34;&#34;&#34;
        return pickle.dumps(_PersistenceWrapper(
            objects=self.objects, relationships=self.relationships))

    @staticmethod
    def loads(asbytes: bytes):  # -&gt; RelationshipManager:
        &#34;&#34;&#34;Load relationship tuples and objects from pickled bytes. 
        Returns a `RelationshipManager` instance.
        &#34;&#34;&#34;
        data: _PersistenceWrapper = pickle.loads(asbytes)
        rm = RelationshipManager()
        rm.objects = data.objects
        rm.relationships = data.relationships
        return rm

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear all relationships, does not affect .objects - if you want to clear that too then
        assign a new empty object to it.  E.g. rm.objects = Namespace()
        &#34;&#34;&#34;
        self.rm.clear()
        self.objects = _Namespace()

    # Util

    def debug_print_rels(self):
        &#34;&#34;&#34;Just a diagnostic method to print the relationships in the rm.
        See also the `RelationshipManager.relationships` property.&#34;&#34;&#34;
        print()
        pprint.pprint(self.relationships)


# Documentation
__pdoc__ = {}

__pdoc__[&#39;relmgr.relationship_manager&#39;] = &#34;&#34;&#34;
OOOO
&#34;&#34;&#34;

__pdoc__[&#39;RelationshipManager&#39;] = &#34;&#34;&#34;
    # Welcome to Relationship Manager

    Put simply, create an instance of this class, then call 
    `RelationshipManager.add_rel()` to record relationships between
    any two Python objects.

    You can then make queries e.g. using 
    `RelationshipManager.find_targets()` as needed.

    ## Installation

    ```shell
    pip install relationship-manager
    ```

    ## Usage

    ```python
    from relmgr import RelationshipManager
    
    rm = RelationshipManager()
    rm.enforce(&#34;xtoy&#34;, &#34;onetoone&#34;, &#34;directional&#34;)
    x = object()
    y = object()
    rm.add_rel(x, y, &#34;xtoy&#34;)
    assert rm.find_target(x, &#34;xtoy&#34;) == y
    ```

    ## Constructor

    Set the option `caching` if you want faster performance using Python
        `lru_cache` technology - defaults to `True`.

    ## What is an object?

    Any Python object can be used as a `source` or `target`. 
    A pointer goes from `source` to `target`.

    You can also use strings as a `source` or `target`. This might be where you
    are representing abstract relationships and need to have real Python objects
    involved. E.g. `RelationshipManager.add_rel(&#39;a&#39;, &#39;b&#39;)`

    ## What is a relationship?

    A relationship is a pointer from one object to another.

    ## What is a relationship id?

    Allows you to have multiple, different relationships between two objects.
    Object `a` might point to both `b` and `c` under relationship id 1 - 
    and at the same time `a` could point only to `c` under relationship id 2.

    A `rel_id` can be an integer or descriptive string e.g. &#34;x-to-y&#34;.
    The default value of `rel_id` is 1.

    ## What is a &#39;back pointer&#39;?

    Its an implicity pointer (or relationship). For example is `a` points to `b`
    then you can say `b` is pointed to by `a`. Back pointers usually need
    explicit wiring and are a pain to maintain since both sides of the
    relationship need to synchronise - see [Martin Fowler ‘Refactorings’
    book](https://martinfowler.com/books/refactoring.html) p. 197 “Change
    Unidirectional Association to Bidirectional”. Relationship Manager makes
    things easy, you can add a single relationship then simply use the query
    `RelationshipManager.find_sources` passing in the target e.g. `b`. See
    https://abulka.github.io/projects/patterns/relationship-manager/ for more
    discussion.
&#34;&#34;&#34;

__pdoc__[&#39;RelationshipManager.dumps&#39;] = &#34;&#34;&#34;
    Persistent Relationship Manager.  

    Provides an attribute object called `.objects` where you can keep all the
    objects involved in relationships e.g.

        rm.objects.obj1 = Entity(strength=1, wise=True, experience=80)

    Then when you persist the Relationship Manager both the objects and
    relations are pickled and later restored. This means your objects are
    accessible by attribute name e.g. rm.objects.obj1 at all times. You can
    assign these references to local variables for convenience e.g.

        obj1 = rm.objects.obj1

    Usage:
        ```
        # persist
        asbytes = rm.dumps()

        # resurrect
        rm2 = RelationshipManagerPersistent.loads(asbytes)
        ```
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="relmgr.relationship_manager.RelationshipManager"><code class="flex name class">
<span>class <span class="ident">RelationshipManager</span></span>
<span>(</span><span>caching: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="welcome-to-relationship-manager">Welcome to Relationship Manager</h1>
<p>Put simply, create an instance of this class, then call
<code><a title="relmgr.relationship_manager.RelationshipManager.add_rel" href="#relmgr.relationship_manager.RelationshipManager.add_rel">RelationshipManager.add_rel()</a></code> to record relationships between
any two Python objects.</p>
<p>You can then make queries e.g. using
<code><a title="relmgr.relationship_manager.RelationshipManager.find_targets" href="#relmgr.relationship_manager.RelationshipManager.find_targets">RelationshipManager.find_targets()</a></code> as needed.</p>
<h2 id="installation">Installation</h2>
<pre><code class="language-shell">pip install relationship-manager
</code></pre>
<h2 id="usage">Usage</h2>
<pre><code class="language-python">from relmgr import RelationshipManager

rm = RelationshipManager()
rm.enforce(&quot;xtoy&quot;, &quot;onetoone&quot;, &quot;directional&quot;)
x = object()
y = object()
rm.add_rel(x, y, &quot;xtoy&quot;)
assert rm.find_target(x, &quot;xtoy&quot;) == y
</code></pre>
<h2 id="constructor">Constructor</h2>
<p>Set the option <code>caching</code> if you want faster performance using Python
<code>lru_cache</code> technology - defaults to <code>True</code>.</p>
<h2 id="what-is-an-object">What is an object?</h2>
<p>Any Python object can be used as a <code>source</code> or <code>target</code>.
A pointer goes from <code>source</code> to <code>target</code>.</p>
<p>You can also use strings as a <code>source</code> or <code>target</code>. This might be where you
are representing abstract relationships and need to have real Python objects
involved. E.g. <code>RelationshipManager.add_rel('a', 'b')</code></p>
<h2 id="what-is-a-relationship">What is a relationship?</h2>
<p>A relationship is a pointer from one object to another.</p>
<h2 id="what-is-a-relationship-id">What is a relationship id?</h2>
<p>Allows you to have multiple, different relationships between two objects.
Object <code>a</code> might point to both <code>b</code> and <code>c</code> under relationship id 1 -
and at the same time <code>a</code> could point only to <code>c</code> under relationship id 2.</p>
<p>A <code>rel_id</code> can be an integer or descriptive string e.g. "x-to-y".
The default value of <code>rel_id</code> is 1.</p>
<h2 id="what-is-a-back-pointer">What is a 'back pointer'?</h2>
<p>Its an implicity pointer (or relationship). For example is <code>a</code> points to <code>b</code>
then you can say <code>b</code> is pointed to by <code>a</code>. Back pointers usually need
explicit wiring and are a pain to maintain since both sides of the
relationship need to synchronise - see <a href="https://martinfowler.com/books/refactoring.html">Martin Fowler ‘Refactorings’
book</a> p. 197 “Change
Unidirectional Association to Bidirectional”. Relationship Manager makes
things easy, you can add a single relationship then simply use the query
<code><a title="relmgr.relationship_manager.RelationshipManager.find_sources" href="#relmgr.relationship_manager.RelationshipManager.find_sources">RelationshipManager.find_sources()</a></code> passing in the target e.g. <code>b</code>. See
<a href="https://abulka.github.io/projects/patterns/relationship-manager/">https://abulka.github.io/projects/patterns/relationship-manager/</a> for more
discussion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationshipManager():
    &#34;&#34;&#34;Main Relationship Manager to use in your projects.&#34;&#34;&#34;

    def __init__(self, caching: bool = True) -&gt; None:
        &#34;&#34;&#34;Constructor.  Set the option `caching` if you want
        faster performance using Python `lru_cache` technology 
        - defaults to True.
        &#34;&#34;&#34;
        if caching:
            self.rm = _RelationshipManagerCaching()
        else:
            self.rm = _EnforcingRelationshipManager()

        self.objects = _Namespace()
        &#34;&#34;&#34;Optional place for storing objects involved in relationships, so the objects are saved.
        Assign to this `.objects` namespace directly to record your objects
        for persistence puposes.
        &#34;&#34;&#34;

    def _get_relationships(self) -&gt; List[Tuple[object, object, Union[int, str]]]:
        &#34;&#34;&#34;Getter&#34;&#34;&#34;
        return self.rm._get_relationships()

    def _set_relationships(self, listofrelationshiptuples: List[Tuple[object, object, Union[int, str]]]) -&gt; None:
        self.rm._set_relationships(listofrelationshiptuples)
        &#34;&#34;&#34;Setter&#34;&#34;&#34;

    relationships = property(_get_relationships, _set_relationships)
    &#34;&#34;&#34;Property to get flat list of relationships tuples&#34;&#34;&#34;

    def add_rel(self, source, target, rel_id=1) -&gt; None:
        &#34;&#34;&#34;Add relationships between `source` and `target` under the optional
        relationship id `rel_id`. The `source` and `target` are typically Python
        objects but can be strings. The `rel_id` is a string or integer and
        defaults to 1. Note that `rel_id` need not be specified unless you want
        to model multiple different relationships between the same objects, thus
        keeping relationships in different &#39;namespaces&#39; as it were.
        &#34;&#34;&#34;
        self.rm.add_rel(source, target, rel_id)

    def remove_rel(self, source, target, rel_id=1) -&gt; None:
        &#34;&#34;&#34;Remove all relationships between `source` and `target` of type `rel_id`.
        If you specify `None` for any parameter a wildcard match removal will occur.
        For example:

        Syntax    | Meaning
        --------|------
        `remove_rel(&#39;a&#39;, &#39;b&#39;)`     | remove all relationships between &#39;a&#39; and &#39;b&#39;
        `remove_rel(&#39;a&#39;, &#39;b&#39;, None)`     | remove all relationships between &#39;a&#39; and &#39;b&#39;
        `remove_rel(&#39;a&#39;, &#39;b&#39;, &#39;r1&#39;)`     | remove the &#39;r1&#39; relationship between &#39;a&#39; and &#39;b&#39;
        `remove_rel(&#39;a&#39;, None)`     | remove all pointers (relationships) from &#39;a&#39;
        `remove_rel(None, &#39;b&#39;)`     | remove any pointers (relationships) to &#39;b&#39;
        &#34;&#34;&#34;
        self.rm.remove_rel(source, target, rel_id)

    def find_targets(self, source, rel_id=1) -&gt; List:
        &#34;&#34;&#34;Find all objects pointed to by me - all the things &#39;source&#39; is pointing at.&#34;&#34;&#34;
        return self.rm._find_objects(source, None, rel_id)

    def find_target(self, source, rel_id=1) -&gt; object:
        &#34;&#34;&#34;Find first object pointed to by me - first target&#34;&#34;&#34;
        return self.rm._find_object(source, None, rel_id)

    def find_sources(self, target, rel_id=1) -&gt; List:
        &#34;&#34;&#34;Find all objects pointing to me. A &#39;back pointer&#39; query.&#34;&#34;&#34;
        return self.rm._find_objects(None, target, rel_id)

    def find_source(self, target, rel_id=1) -&gt; object:
        &#34;&#34;&#34;Find first object pointing to me - first source. A &#39;back pointer&#39; query.&#34;&#34;&#34;
        return self.rm._find_object(None, target, rel_id)

    def is_rel(self, source, target, rel_id=1) -&gt; bool:
        &#34;&#34;&#34;Returns T/F if relationship exists.&#34;&#34;&#34;
        return self.rm._find_objects(source, target, rel_id)

    def find_rels(self, source, target) -&gt; List:
        &#34;&#34;&#34;Returns a list of the relationships between source and target.
        Returns a list of relationship ids.
        &#34;&#34;&#34;
        return self.rm._find_objects(source, target, None)

    def enforce(self, relId, cardinality, directionality=&#34;directional&#34;):
        &#34;&#34;&#34;Enforce a relationship by auto creating reciprocal relationships in the case of 
        bidirectional relationships, and by overwriting existing relationships if in the case
        of one-to-one cardinality?
        &#34;&#34;&#34;
        self.rm.enforce(relId, cardinality, directionality)

    def dumps(self) -&gt; bytes:
        &#34;&#34;&#34;Dump relationship tuples and objects to pickled bytes.
        The `objects` attribute and all objects stored therein
        (within the instance of `RelationshipManager.objects`) also get persisted.
        &#34;&#34;&#34;
        return pickle.dumps(_PersistenceWrapper(
            objects=self.objects, relationships=self.relationships))

    @staticmethod
    def loads(asbytes: bytes):  # -&gt; RelationshipManager:
        &#34;&#34;&#34;Load relationship tuples and objects from pickled bytes. 
        Returns a `RelationshipManager` instance.
        &#34;&#34;&#34;
        data: _PersistenceWrapper = pickle.loads(asbytes)
        rm = RelationshipManager()
        rm.objects = data.objects
        rm.relationships = data.relationships
        return rm

    def clear(self) -&gt; None:
        &#34;&#34;&#34;Clear all relationships, does not affect .objects - if you want to clear that too then
        assign a new empty object to it.  E.g. rm.objects = Namespace()
        &#34;&#34;&#34;
        self.rm.clear()
        self.objects = _Namespace()

    # Util

    def debug_print_rels(self):
        &#34;&#34;&#34;Just a diagnostic method to print the relationships in the rm.
        See also the `RelationshipManager.relationships` property.&#34;&#34;&#34;
        print()
        pprint.pprint(self.relationships)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="relmgr.relationship_manager.RelationshipManager.loads"><code class="name flex">
<span>def <span class="ident">loads</span></span>(<span>asbytes: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Load relationship tuples and objects from pickled bytes.
Returns a <code><a title="relmgr.relationship_manager.RelationshipManager" href="#relmgr.relationship_manager.RelationshipManager">RelationshipManager</a></code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def loads(asbytes: bytes):  # -&gt; RelationshipManager:
    &#34;&#34;&#34;Load relationship tuples and objects from pickled bytes. 
    Returns a `RelationshipManager` instance.
    &#34;&#34;&#34;
    data: _PersistenceWrapper = pickle.loads(asbytes)
    rm = RelationshipManager()
    rm.objects = data.objects
    rm.relationships = data.relationships
    return rm</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="relmgr.relationship_manager.RelationshipManager.objects"><code class="name">var <span class="ident">objects</span></code></dt>
<dd>
<div class="desc"><p>Optional place for storing objects involved in relationships, so the objects are saved.
Assign to this <code>.objects</code> namespace directly to record your objects
for persistence puposes.</p></div>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.relationships"><code class="name">var <span class="ident">relationships</span> : List[Tuple[object, object, Union[int, str]]]</code></dt>
<dd>
<div class="desc"><p>Property to get flat list of relationships tuples</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _get_relationships(self) -&gt; List[Tuple[object, object, Union[int, str]]]:
    &#34;&#34;&#34;Getter&#34;&#34;&#34;
    return self.rm._get_relationships()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="relmgr.relationship_manager.RelationshipManager.add_rel"><code class="name flex">
<span>def <span class="ident">add_rel</span></span>(<span>self, source, target, rel_id=1) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add relationships between <code>source</code> and <code>target</code> under the optional
relationship id <code>rel_id</code>. The <code>source</code> and <code>target</code> are typically Python
objects but can be strings. The <code>rel_id</code> is a string or integer and
defaults to 1. Note that <code>rel_id</code> need not be specified unless you want
to model multiple different relationships between the same objects, thus
keeping relationships in different 'namespaces' as it were.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_rel(self, source, target, rel_id=1) -&gt; None:
    &#34;&#34;&#34;Add relationships between `source` and `target` under the optional
    relationship id `rel_id`. The `source` and `target` are typically Python
    objects but can be strings. The `rel_id` is a string or integer and
    defaults to 1. Note that `rel_id` need not be specified unless you want
    to model multiple different relationships between the same objects, thus
    keeping relationships in different &#39;namespaces&#39; as it were.
    &#34;&#34;&#34;
    self.rm.add_rel(source, target, rel_id)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all relationships, does not affect .objects - if you want to clear that too then
assign a new empty object to it.
E.g. rm.objects = Namespace()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Clear all relationships, does not affect .objects - if you want to clear that too then
    assign a new empty object to it.  E.g. rm.objects = Namespace()
    &#34;&#34;&#34;
    self.rm.clear()
    self.objects = _Namespace()</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.debug_print_rels"><code class="name flex">
<span>def <span class="ident">debug_print_rels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Just a diagnostic method to print the relationships in the rm.
See also the <code><a title="relmgr.relationship_manager.RelationshipManager.relationships" href="#relmgr.relationship_manager.RelationshipManager.relationships">RelationshipManager.relationships</a></code> property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_print_rels(self):
    &#34;&#34;&#34;Just a diagnostic method to print the relationships in the rm.
    See also the `RelationshipManager.relationships` property.&#34;&#34;&#34;
    print()
    pprint.pprint(self.relationships)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.dumps"><code class="name flex">
<span>def <span class="ident">dumps</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Persistent Relationship Manager.
</p>
<p>Provides an attribute object called <code>.objects</code> where you can keep all the
objects involved in relationships e.g.</p>
<pre><code>rm.objects.obj1 = Entity(strength=1, wise=True, experience=80)
</code></pre>
<p>Then when you persist the Relationship Manager both the objects and
relations are pickled and later restored. This means your objects are
accessible by attribute name e.g. rm.objects.obj1 at all times. You can
assign these references to local variables for convenience e.g.</p>
<pre><code>obj1 = rm.objects.obj1
</code></pre>
<h2 id="usage">Usage</h2>
<pre><code># persist
asbytes = rm.dumps()

# resurrect
rm2 = RelationshipManagerPersistent.loads(asbytes)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumps(self) -&gt; bytes:
    &#34;&#34;&#34;Dump relationship tuples and objects to pickled bytes.
    The `objects` attribute and all objects stored therein
    (within the instance of `RelationshipManager.objects`) also get persisted.
    &#34;&#34;&#34;
    return pickle.dumps(_PersistenceWrapper(
        objects=self.objects, relationships=self.relationships))</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.enforce"><code class="name flex">
<span>def <span class="ident">enforce</span></span>(<span>self, relId, cardinality, directionality='directional')</span>
</code></dt>
<dd>
<div class="desc"><p>Enforce a relationship by auto creating reciprocal relationships in the case of
bidirectional relationships, and by overwriting existing relationships if in the case
of one-to-one cardinality?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enforce(self, relId, cardinality, directionality=&#34;directional&#34;):
    &#34;&#34;&#34;Enforce a relationship by auto creating reciprocal relationships in the case of 
    bidirectional relationships, and by overwriting existing relationships if in the case
    of one-to-one cardinality?
    &#34;&#34;&#34;
    self.rm.enforce(relId, cardinality, directionality)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.find_rels"><code class="name flex">
<span>def <span class="ident">find_rels</span></span>(<span>self, source, target) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the relationships between source and target.
Returns a list of relationship ids.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_rels(self, source, target) -&gt; List:
    &#34;&#34;&#34;Returns a list of the relationships between source and target.
    Returns a list of relationship ids.
    &#34;&#34;&#34;
    return self.rm._find_objects(source, target, None)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.find_source"><code class="name flex">
<span>def <span class="ident">find_source</span></span>(<span>self, target, rel_id=1) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Find first object pointing to me - first source. A 'back pointer' query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_source(self, target, rel_id=1) -&gt; object:
    &#34;&#34;&#34;Find first object pointing to me - first source. A &#39;back pointer&#39; query.&#34;&#34;&#34;
    return self.rm._find_object(None, target, rel_id)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.find_sources"><code class="name flex">
<span>def <span class="ident">find_sources</span></span>(<span>self, target, rel_id=1) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><p>Find all objects pointing to me. A 'back pointer' query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_sources(self, target, rel_id=1) -&gt; List:
    &#34;&#34;&#34;Find all objects pointing to me. A &#39;back pointer&#39; query.&#34;&#34;&#34;
    return self.rm._find_objects(None, target, rel_id)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.find_target"><code class="name flex">
<span>def <span class="ident">find_target</span></span>(<span>self, source, rel_id=1) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Find first object pointed to by me - first target</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_target(self, source, rel_id=1) -&gt; object:
    &#34;&#34;&#34;Find first object pointed to by me - first target&#34;&#34;&#34;
    return self.rm._find_object(source, None, rel_id)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.find_targets"><code class="name flex">
<span>def <span class="ident">find_targets</span></span>(<span>self, source, rel_id=1) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><p>Find all objects pointed to by me - all the things 'source' is pointing at.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_targets(self, source, rel_id=1) -&gt; List:
    &#34;&#34;&#34;Find all objects pointed to by me - all the things &#39;source&#39; is pointing at.&#34;&#34;&#34;
    return self.rm._find_objects(source, None, rel_id)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.is_rel"><code class="name flex">
<span>def <span class="ident">is_rel</span></span>(<span>self, source, target, rel_id=1) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns T/F if relationship exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_rel(self, source, target, rel_id=1) -&gt; bool:
    &#34;&#34;&#34;Returns T/F if relationship exists.&#34;&#34;&#34;
    return self.rm._find_objects(source, target, rel_id)</code></pre>
</details>
</dd>
<dt id="relmgr.relationship_manager.RelationshipManager.remove_rel"><code class="name flex">
<span>def <span class="ident">remove_rel</span></span>(<span>self, source, target, rel_id=1) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all relationships between <code>source</code> and <code>target</code> of type <code>rel_id</code>.
If you specify <code>None</code> for any parameter a wildcard match removal will occur.
For example:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove_rel('a', 'b')</code></td>
<td>remove all relationships between 'a' and 'b'</td>
</tr>
<tr>
<td><code>remove_rel('a', 'b', None)</code></td>
<td>remove all relationships between 'a' and 'b'</td>
</tr>
<tr>
<td><code>remove_rel('a', 'b', 'r1')</code></td>
<td>remove the 'r1' relationship between 'a' and 'b'</td>
</tr>
<tr>
<td><code>remove_rel('a', None)</code></td>
<td>remove all pointers (relationships) from 'a'</td>
</tr>
<tr>
<td><code>remove_rel(None, 'b')</code></td>
<td>remove any pointers (relationships) to 'b'</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_rel(self, source, target, rel_id=1) -&gt; None:
    &#34;&#34;&#34;Remove all relationships between `source` and `target` of type `rel_id`.
    If you specify `None` for any parameter a wildcard match removal will occur.
    For example:

    Syntax    | Meaning
    --------|------
    `remove_rel(&#39;a&#39;, &#39;b&#39;)`     | remove all relationships between &#39;a&#39; and &#39;b&#39;
    `remove_rel(&#39;a&#39;, &#39;b&#39;, None)`     | remove all relationships between &#39;a&#39; and &#39;b&#39;
    `remove_rel(&#39;a&#39;, &#39;b&#39;, &#39;r1&#39;)`     | remove the &#39;r1&#39; relationship between &#39;a&#39; and &#39;b&#39;
    `remove_rel(&#39;a&#39;, None)`     | remove all pointers (relationships) from &#39;a&#39;
    `remove_rel(None, &#39;b&#39;)`     | remove any pointers (relationships) to &#39;b&#39;
    &#34;&#34;&#34;
    self.rm.remove_rel(source, target, rel_id)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#relationship-manager">Relationship Manager</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="relmgr" href="index.html">relmgr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="relmgr.relationship_manager.RelationshipManager" href="#relmgr.relationship_manager.RelationshipManager">RelationshipManager</a></code></h4>
<ul class="two-column">
<li><code><a title="relmgr.relationship_manager.RelationshipManager.add_rel" href="#relmgr.relationship_manager.RelationshipManager.add_rel">add_rel</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.clear" href="#relmgr.relationship_manager.RelationshipManager.clear">clear</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.debug_print_rels" href="#relmgr.relationship_manager.RelationshipManager.debug_print_rels">debug_print_rels</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.dumps" href="#relmgr.relationship_manager.RelationshipManager.dumps">dumps</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.enforce" href="#relmgr.relationship_manager.RelationshipManager.enforce">enforce</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.find_rels" href="#relmgr.relationship_manager.RelationshipManager.find_rels">find_rels</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.find_source" href="#relmgr.relationship_manager.RelationshipManager.find_source">find_source</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.find_sources" href="#relmgr.relationship_manager.RelationshipManager.find_sources">find_sources</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.find_target" href="#relmgr.relationship_manager.RelationshipManager.find_target">find_target</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.find_targets" href="#relmgr.relationship_manager.RelationshipManager.find_targets">find_targets</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.is_rel" href="#relmgr.relationship_manager.RelationshipManager.is_rel">is_rel</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.loads" href="#relmgr.relationship_manager.RelationshipManager.loads">loads</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.objects" href="#relmgr.relationship_manager.RelationshipManager.objects">objects</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.relationships" href="#relmgr.relationship_manager.RelationshipManager.relationships">relationships</a></code></li>
<li><code><a title="relmgr.relationship_manager.RelationshipManager.remove_rel" href="#relmgr.relationship_manager.RelationshipManager.remove_rel">remove_rel</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>